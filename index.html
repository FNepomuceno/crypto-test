<!doctype html>
<html>
<head>
<meta charset="UTF-8">
</head>
<body>
<script type="module" src="key.mjs"></script>
<script type="module" src="store.mjs"></script>
<script type="module" src="encrypt.mjs"></script>
<script type="module" src="sign.mjs"></script>
<script type="module">
import {
  generateEcdhKeypair,
  deriveSecretKey,
  deriveSecretBits,
  encryptAesGcm,
  decryptAesGcm,
  generateRsaKeypair,
  encryptRsa,
  decryptRsa
} from './encrypt.mjs'
import {
  generateEcdsaKeypair,
  signEcdsa,
  verifyEcdsa,
  generateHmacKey,
  signHmac,
  verifyHmac
} from './sign.mjs'
import {
  createUser,
  verifyPassword,
  resetPassword
} from './user.mjs'

async function testSecretEcdh() {
  // Generate ECDH public/private keypairs for A and B
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateEcdhKeypair()
  let {
    privateKey: bPrivate,
    publicKey: bPublic
  } = await generateEcdhKeypair()

  // Derive secret bits from their own private key
  // and the other's public key
  let aSecret = await deriveSecretBits(aPrivate, bPublic)
  let bSecret = await deriveSecretBits(bPrivate, aPublic)
  let bSecret16 = await deriveSecretBits(bPrivate, aPublic, 16)

  // Tests

  // The secret keys generated by A and by B should be the same key
  let aSecretHex = await bufferToHex(aSecret)
  let bSecretHex = await bufferToHex(bSecret)
  let bSecretHex16 = await bufferToHex(bSecret16)
  console.log("A's secret bits:", aSecretHex)
  console.log("B's secret bits:", bSecretHex)
  console.log('Secrets match:', aSecretHex === bSecretHex)
  console.log("B's secret to 16 bytes:", bSecretHex16)

  function bufferToHex(buffer) {
    let data = Array.from(new Uint8Array(buffer))
    return data.map(x => x.toString(16).padStart(2, '0')).join('')
  }
}

async function testEncryptAesGcm() {
  // Generate ECDH public/private keypairs for A and B
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateEcdhKeypair()
  let {
    privateKey: bPrivate,
    publicKey: bPublic
  } = await generateEcdhKeypair()

  // Derive AES-GCM keys from their own private key
  // and the other's public key
  let aSecret = await deriveSecretKey(aPrivate, bPublic)
  let bSecret = await deriveSecretKey(bPrivate, aPublic)

  // A generates and encrypts data to send to B
  let data = window.crypto.getRandomValues(new Uint8Array(64))
  let { iv, encryptedData: encrypted } = await encryptAesGcm(aSecret, data)

  // B decrypts data with encrypted data and iv given
  let decrypted = await decryptAesGcm(bSecret, encrypted, iv)

  // Tests

  // The secret keys generated by A and by B should be the same key
  let aSecretHex = await keyToHex(aSecret, 'raw')
  let bSecretHex = await keyToHex(bSecret, 'raw')
  console.log("A's secret key:", aSecretHex)
  console.log("B's secret key:", bSecretHex)
  console.log('Secrets match:', aSecretHex === bSecretHex)

  // The original data and the data decrypted by B should be the same
  let dataHex = bufferToHex(data)
  let decryptedHex = bufferToHex(decrypted)
  console.log('Original data:', dataHex)
  console.log('Decrypted data:', decryptedHex)
  console.log('Data encrypted/decrpted successfully:',
    bufferToHex(data) === bufferToHex(decrypted))

  async function keyToHex(key, type) {
    let buffer = await window.crypto.subtle.exportKey(type, key)
    return bufferToHex(buffer)
  }

  function bufferToHex(buffer) {
    let data = Array.from(new Uint8Array(buffer))
    return data.map(x => x.toString(16).padStart(2, '0')).join('')
  }
}

async function testEncryptRsa() {
  // Generate RSA public/private keypair for A
  console.time('generate rsa keypair')
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateRsaKeypair()
  console.timeEnd('generate rsa keypair')

  // B encrypts data with A's public key
  let data = window.crypto.getRandomValues(new Uint8Array(16))
  let encrypted = await encryptRsa(aPublic, data)

  // A decrypts encrypted data their own private key
  let decrypted = await decryptRsa(aPrivate, encrypted)

  // Tests

  // The original data and the data decrypted by A should be the same
  let dataHex = bufferToHex(data)
  let decryptedHex = bufferToHex(decrypted)
  console.log('Original data:', dataHex)
  console.log('Decrypted data:', decryptedHex)
  console.log('Data encrypted/decrpted successfully:',
    bufferToHex(data) === bufferToHex(decrypted))

  async function keyToHex(key, type) {
    let buffer = await window.crypto.subtle.exportKey(type, key)
    return bufferToHex(buffer)
  }

  function bufferToHex(buffer) {
    let data = Array.from(new Uint8Array(buffer))
    return data.map(x => x.toString(16).padStart(2, '0')).join('')
  }
}

async function testSignEcdsa() {
  // Generate ECDSA public/private keypairs for A
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateEcdsaKeypair()

  // A sends and signs data for B using their own private key
  let data = window.crypto.getRandomValues(new Uint8Array(64))
  let signature = await signEcdsa(aPrivate, data)

  // B verifies A's signature using A's public key
  let result = await verifyEcdsa(aPublic, data, signature)

  // Tests

  // Signature is verified
  console.log('Data signed/verified successfully:', result)
}

async function testSignHmac() {
  // Generate HMAC key
  let key = await generateHmacKey()

  // A sends and signs data for B using the shared key
  let data = window.crypto.getRandomValues(new Uint8Array(64))
  let signature = await signHmac(key, data)

  // B verifies A's signature using the shared key
  let result = await verifyHmac(key, data, signature)

  // Tests

  // Signature is verified
  console.log('Data signed/verified successfully:', result)
}

async function testUser() {
  let a = await createUser('correct password')
  let aPassHash1 = a.passwordHash
  let verifySuccess = await verifyPassword(a, 'correct password')
  let verifyFailure = await verifyPassword(a, 'incorrect password')
  a = await resetPassword(a, 'correct password')
  let aPassHash2 = a.passwordHash
  let verifySuccess2 = await verifyPassword(a, 'correct password')

  // Tests

  // Verify Password works as it should
  console.log('Password verify correct password:', verifySuccess)
  console.log('Password verify incorrect password:', verifyFailure)

  // Password hashes change even with the same password on reset
  console.log('Original hash:', aPassHash1)
  console.log('Changed hash: ', aPassHash2)
  console.log('Hashes changed:', aPassHash1 !== aPassHash2)

  console.log('Password verify correct password after reset:', verifySuccess2)
}

// testSecretEcdh()
// testEncryptAesGcm()
// testEncryptRsa()
// testSignEcdsa()
// testSignHmac()
testUser()
</script>
</body>
</html>

<!doctype html>
<html>
<head>
<meta charset="UTF-8">
</head>
<body>
<script type="module" src="key.mjs"></script>
<script type="module" src="store.mjs"></script>
<script type="module" src="encrypt.mjs"></script>
<script type="module" src="sign.mjs"></script>
<script type="module">
import {
  generateEcdhKeypair,
  deriveSecretKey,
  encryptAesGcm,
  decryptAesGcm,
  generateRsaKeypair,
  encryptRsa,
  decryptRsa
} from './encrypt.mjs'

async function testEncryptAesGcm() {
  // Generate ECDH public/private keypairs for A and B
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateEcdhKeypair()
  let {
    privateKey: bPrivate,
    publicKey: bPublic
  } = await generateEcdhKeypair()

  // Derive AES-GCM keys from their own private key
  // and the other's public key
  let aSecret = await deriveSecretKey(aPrivate, bPublic)
  let bSecret = await deriveSecretKey(bPrivate, aPublic)

  // A generates and encrypts data to send to B
  let data = window.crypto.getRandomValues(new Uint8Array(64))
  let { iv, encryptedData: encrypted } = await encryptAesGcm(aSecret, data)

  // B decrypts data with encrypted data and iv given
  let decrypted = await decryptAesGcm(bSecret, encrypted, iv)

  // Tests

  // The secret keys generated by A and by B should be the same key
  let aSecretHex = await keyToHex(aSecret, 'raw')
  let bSecretHex = await keyToHex(bSecret, 'raw')
  console.log("A's secret key:", aSecretHex)
  console.log("B's secret key:", bSecretHex)
  console.log('Secrets match:', aSecretHex === bSecretHex)

  // The original data and the data decrypted by B should be the same
  let dataHex = bufferToHex(data)
  let decryptedHex = bufferToHex(decrypted)
  console.log('Original data:', dataHex)
  console.log('Decrypted data:', decryptedHex)
  console.log('Data encrypted/decrpted successfully:',
    bufferToHex(data) === bufferToHex(decrypted))

  async function keyToHex(key, type) {
    let buffer = await window.crypto.subtle.exportKey(type, key)
    return bufferToHex(buffer)
  }

  function bufferToHex(buffer) {
    let data = Array.from(new Uint8Array(buffer))
    return data.map(x => x.toString(16).padStart(2, '0')).join('')
  }
}

async function testEncryptRsa() {
  // Generate RSA public/private keypairs for A and B
  console.time('generate rsa keypair')
  let {
    privateKey: aPrivate,
    publicKey: aPublic
  } = await generateRsaKeypair()
  console.timeEnd('generate rsa keypair')

  // B encrypts data with A's public key
  let data = window.crypto.getRandomValues(new Uint8Array(16))
  let encrypted = await encryptRsa(aPublic, data)

  // A decrypts encrypted data their own private key
  let decrypted = await decryptRsa(aPrivate, encrypted)

  // Tests

  // The original data and the data decrypted by A should be the same
  let dataHex = bufferToHex(data)
  let decryptedHex = bufferToHex(decrypted)
  console.log('Original data:', dataHex)
  console.log('Decrypted data:', decryptedHex)
  console.log('Data encrypted/decrpted successfully:',
    bufferToHex(data) === bufferToHex(decrypted))

  async function keyToHex(key, type) {
    let buffer = await window.crypto.subtle.exportKey(type, key)
    return bufferToHex(buffer)
  }

  function bufferToHex(buffer) {
    let data = Array.from(new Uint8Array(buffer))
    return data.map(x => x.toString(16).padStart(2, '0')).join('')
  }
}

// testEncryptAesGcm()
testEncryptRsa()
</script>
</body>
</html>
